---
const { placeholder = 'Escribe un mensaje…' } = Astro.props;
// Obtener la URL del backend desde variables de entorno
// Si no existe, usar localhost:3000 como fallback
const backendUrl = import.meta.env.PUBLIC_BACKEND_URL || 'http://localhost:3000';
// Rutas GET para controlar LEDs (opcionales)
const ledOnUrl = import.meta.env.PUBLIC_LED_ON_URL || '';
const ledOffUrl = import.meta.env.PUBLIC_LED_OFF_URL || '';
const ledAllOnUrl = import.meta.env.PUBLIC_LED_ALL_ON_URL || '';
const ledAllOffUrl = import.meta.env.PUBLIC_LED_ALL_OFF_URL || '';
const ledDefaultNum = import.meta.env.PUBLIC_LED_NUM || '1';
const ledCount = import.meta.env.PUBLIC_LED_COUNT || '3';
---

<div class="w-full h-full flex flex-col">
	<div id="messages" class="flex-1 overflow-y-auto p-4 sm:p-6 space-y-4 sm:space-y-6 min-h-0">
	
	</div>

	<div class="border-t border-white/30 p-4 sm:p-5 bg-gradient-to-r from-white/5 to-white/10">
		<form id="chat-form" class="flex gap-2 sm:gap-3" autocomplete="off">
			<input id="user-input" name="message" class="flex-1 backdrop-blur-sm bg-white/90 border border-white/50 rounded-xl px-3 sm:px-4 py-2.5 sm:py-3 text-sm sm:text-base focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent shadow-lg transition-all" placeholder={placeholder} />
			<button type="submit" class="px-4 sm:px-6 py-2.5 sm:py-3 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white text-sm sm:text-base font-bold rounded-xl transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-xl whitespace-nowrap">
				<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
				</svg>
			</button>
		</form>
		<div id="error" class="mt-3 hidden text-xs sm:text-sm text-red-100 bg-red-500/20 backdrop-blur-sm px-3 py-2 rounded-lg border border-red-300/30"></div>
	</div>
</div>

<script define:vars={{ backendUrl, ledOnUrl, ledOffUrl, ledAllOnUrl, ledAllOffUrl, ledDefaultNum, ledCount }}>
  // @ts-nocheck
  const form = /** @type {HTMLFormElement | null} */ (document.getElementById('chat-form'));
  const input = /** @type {HTMLInputElement | null} */ (document.getElementById('user-input'));
  const messages = /** @type {HTMLDivElement | null} */ (document.getElementById('messages'));
  const errorBox = /** @type {HTMLDivElement | null} */ (document.getElementById('error'));
  
  // URL del backend desde variable de entorno
  // Usa la variable pasada desde el servidor o fallback a localhost:3000
  const API_URL = backendUrl || 'http://localhost:3000';

  // URLs de LED control
  // Construcción de URLs para LED: usa variables explícitas si existen; si no, usa las rutas del backend
  let LED_ON = ledOnUrl || '';
  let LED_OFF = ledOffUrl || '';
  const LED_NUM = Number(ledDefaultNum || 1) || 1;
  if (!LED_ON) LED_ON = `${API_URL}/api/chat/led/${LED_NUM}/on`;
  if (!LED_OFF) LED_OFF = `${API_URL}/api/chat/led/${LED_NUM}/off`;
  const ALL_ON = ledAllOnUrl || '';
  const ALL_OFF = ledAllOffUrl || '';
  const LED_COUNT = Number(ledCount || 3) || 3;
  
  // Log para debugging (eliminar en producción)
  console.log('Backend URL configurada:', API_URL, { LED_ON, LED_OFF, ALL_ON: ALL_ON ? 'def' : 'no', ALL_OFF: ALL_OFF ? 'def' : 'no', LED_COUNT });

  // Prueba de conexión con el backend
  fetch(`${API_URL}/api/chat`, {
    method: 'GET'
  })
    .then(res => res.json())
    .then(data => console.log('✅ Respuesta del backend:', data))
    .catch(err => console.error('❌ Error conectando con backend:', err));

  // Avatar de la IA (icono de casa)
  function createAvatar() {
    const avatar = document.createElement('div');
    avatar.className = 'w-8 h-8 sm:w-10 sm:h-10 bg-gradient-to-br from-cyan-500 to-blue-600 rounded-full flex items-center justify-center flex-shrink-0 shadow-lg';
    avatar.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="18" height="18" fill="white" aria-hidden="true">
        <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/>
      </svg>`;
    return avatar;
  }

  /** Renders a message bubble 
   * @param {string} text
   * @param {'user' | 'assistant'} role
   * @param {boolean=} streaming - Si es true, retorna el elemento de texto para streaming
   */
  function addMessage(text, role, streaming = false) {
    const wrapper = document.createElement('div');
    const isUser = role === 'user';
    wrapper.className = `flex gap-2 sm:gap-3 ${isUser ? 'justify-end' : ''}`;
    
    let textDiv;
    
    if (isUser) {
      const content = document.createElement('div');
      content.className = 'max-w-[85%] sm:max-w-[80%] bg-gradient-to-br from-blue-500 to-cyan-500 rounded-2xl px-3 sm:px-4 py-2.5 sm:py-3 shadow-lg';
      textDiv = document.createElement('div');
      textDiv.className = 'text-sm sm:text-base text-white leading-relaxed break-words';
      textDiv.textContent = text;
      content.appendChild(textDiv);
      wrapper.appendChild(content);
    } else {
      const avatar = createAvatar();
      const content = document.createElement('div');
      content.className = 'flex-1 min-w-0 backdrop-blur-sm bg-white/80 rounded-2xl px-3 sm:px-4 py-2.5 sm:py-3 shadow-md border border-white/50';
      textDiv = document.createElement('div');
      textDiv.className = 'text-sm sm:text-base text-gray-900 leading-relaxed break-words';
      textDiv.textContent = text;
      content.appendChild(textDiv);
      
      wrapper.appendChild(avatar);
      wrapper.appendChild(content);
    }
    
    if (messages) {
      messages.appendChild(wrapper);
      messages.scrollTop = messages.scrollHeight;
    }
    
    return streaming ? { wrapper, textDiv } : wrapper;
  }

  /** @param {string=} msg */
  function setError(msg) {
    if (!errorBox) return;
    if (!msg) {
      errorBox.classList.add('hidden');
      errorBox.textContent = '';
      return;
    }
    errorBox.textContent = String(msg);
    errorBox.classList.remove('hidden');
  }

  function createLoaderBubble() {
    const wrapper = document.createElement('div');
    wrapper.className = 'flex gap-2 sm:gap-3';
    
  const avatar = createAvatar();
  
  const content = document.createElement('div');
    content.className = 'flex-1 flex items-center gap-2 backdrop-blur-sm bg-white/80 rounded-2xl px-3 sm:px-4 py-3 shadow-md border border-white/50';
    
    const dots = document.createElement('div');
    dots.className = 'flex items-center gap-1.5';
    for (let i = 0; i < 3; i++) {
      const d = document.createElement('span');
      d.className = 'inline-block h-2 w-2 sm:h-2.5 sm:w-2.5 bg-gradient-to-r from-cyan-500 to-blue-600 rounded-full animate-bounce';
      d.style.animationDelay = `${i * 0.15}s`;
      dots.appendChild(d);
    }
    
    content.appendChild(dots);
    wrapper.appendChild(avatar);
    wrapper.appendChild(content);
    if (messages) {
      messages.appendChild(wrapper);
      messages.scrollTop = messages.scrollHeight;
    }
    return wrapper;
  }

  /** Renders an assistant message with quick-action buttons
   * @param {string} title
   * @param {{label:string, command?:string, meta?:any}[]} options
   */
  function addOptionsMessage(title, options) {
    if (!messages) return;

    const wrapper = document.createElement('div');
    wrapper.className = 'flex gap-2 sm:gap-3';

    const avatar = createAvatar();

    const content = document.createElement('div');
    content.className = 'flex-1 min-w-0 backdrop-blur-sm bg-white/80 rounded-2xl px-3 sm:px-4 py-3 shadow-md border border-white/50';

    const titleEl = document.createElement('div');
    titleEl.className = 'text-sm sm:text-base text-gray-900 mb-3 font-medium';
    titleEl.textContent = title;

    const grid = document.createElement('div');
    grid.className = 'grid grid-cols-2 sm:grid-cols-3 gap-2';

    options.forEach(opt => {
      const btn = document.createElement('button');
      btn.className = 'px-3 py-2 text-xs sm:text-sm rounded-lg bg-gradient-to-r from-blue-500 to-cyan-500 text-white font-semibold shadow hover:brightness-110';
      btn.textContent = opt.label;
      btn.addEventListener('click', () => {
        if (opt.meta && opt.meta.type === 'led-action') {
          wrapper.remove();
          showLedNumberPicker(opt.meta.action);
          return;
        }
        if (opt.meta && opt.meta.type === 'led-action-all') {
          wrapper.remove();
          handleLedAll(opt.meta.action);
          return;
        }
        if (opt.command) {
          sendMessage(opt.command);
          wrapper.remove();
        }
      });
      grid.appendChild(btn);
    });

    content.appendChild(titleEl);
    content.appendChild(grid);
    wrapper.appendChild(avatar);
    wrapper.appendChild(content);
    messages.appendChild(wrapper);
    messages.scrollTop = messages.scrollHeight;
  }

  // Escuchar solicitudes externas para mostrar opciones en el chat
  window.addEventListener('chat:showOptions', (e) => {
    const { title, options } = e.detail || {};
    if (title && Array.isArray(options)) {
      addOptionsMessage(title, options);
    }
  });

  const mockResponses = {
    'encender': 'He encendido las luces según tu solicitud.',
    'prender': 'He encendido las luces según tu solicitud.',
    'apagar': 'He apagado las luces según tu solicitud.',
    'temperatura': 'La temperatura actual en tu hogar es de 22°C.',
    'abrir': 'He abierto la puerta según tu solicitud.',
    'cerrar': 'He cerrado la puerta según tu solicitud.',
    'hola': '¡Hola! Soy tu asistente domótico. ¿En qué puedo ayudarte hoy?',
    'ayuda': 'Puedo ayudarte con: encender/apagar luces, abrir/cerrar puertas y consultar la temperatura actual.'
  };

  /** @param {string} text */
  function getMockResponse(text) {
    const lowerText = text.toLowerCase();
    for (const [key, response] of Object.entries(mockResponses)) {
      if (lowerText.includes(key)) {
        return response;
      }
    }
    return 'No entiendo ese comando. Di "ayuda" para ver los comandos disponibles.';
  }

  /** Simula streaming de texto con efecto de escritura
   * @param {string} fullText
   * @param {HTMLElement} textElement
   */
  async function streamText(fullText, textElement) {
    let currentText = '';
    const words = fullText.split(' ');
    
    for (let i = 0; i < words.length; i++) {
      currentText += (i > 0 ? ' ' : '') + words[i];
      textElement.textContent = currentText;
      if (messages) {
        messages.scrollTop = messages.scrollHeight;
      }
      // Velocidad de escritura variable para efecto más natural
      await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
    }
  }

  function isLedCommand(text) {
    const t = text.toLowerCase();
    if (t.includes('prender') || t.includes('encender')) return 'on';
    if (t.includes('apagar')) return 'off';
    return '';
  }

  async function handleLedCommand(kind) {
    const url = kind === 'on' ? LED_ON : LED_OFF;
    if (!url) return false;
    const loader = createLoaderBubble();
    try {
      const res = await fetch(url, { method: 'GET' });
      loader.remove();
      const ok = res.ok;
      const msg = kind === 'on' ? 'He encendido las luces según tu solicitud.' : 'He apagado las luces según tu solicitud.';
      addMessage(ok ? msg : `No pude completar la acción (HTTP ${res.status})`, 'assistant');
    } catch (e) {
      loader.remove();
      addMessage('No pude conectar con el controlador de luces.', 'assistant');
    }
    return true;
  }

  async function handleLedByNumber(num, action) {
    const url = `${API_URL}/api/chat/led/${num}/${action}`;
    const loader = createLoaderBubble();
    try {
      const res = await fetch(url, { method: 'GET' });
      loader.remove();
      const ok = res.ok;
      const msg = action === 'on' ? `LED ${num} encendido.` : `LED ${num} apagado.`;
      addMessage(ok ? msg : `No pude completar la acción (HTTP ${res.status})`, 'assistant');
    } catch (e) {
      loader.remove();
      addMessage('No pude conectar con el controlador de luces.', 'assistant');
    }
  }

  async function handleLedAll(action) {
    const loader = createLoaderBubble();
    try {
      if ((action === 'on' && ALL_ON) || (action === 'off' && ALL_OFF)) {
        const url = action === 'on' ? ALL_ON : ALL_OFF;
        await fetch(url, { method: 'GET' });
      } else {
        for (let n = 1; n <= LED_COUNT; n++) {
          await fetch(`${API_URL}/api/chat/led/${n}/${action}`, { method: 'GET' });
        }
      }
      loader.remove();
      addMessage(action === 'on' ? 'Todos los LEDs encendidos.' : 'Todos los LEDs apagados.', 'assistant');
    } catch (e) {
      loader.remove();
      addMessage('No pude completar la acción para todos los LEDs.', 'assistant');
    }
  }

  function showLedNumberPicker(action) {
    const opts = [1,2,3].map(n => ({ label: `LED ${n}`, meta: { type: 'led-number', n }}));
    // render and wire
    if (!messages) return;
    const wrapper = document.createElement('div');
    wrapper.className = 'flex gap-2 sm:gap-3';
    const avatar = createAvatar();
    const content = document.createElement('div');
    content.className = 'flex-1 min-w-0 backdrop-blur-sm bg-white/80 rounded-2xl px-3 sm:px-4 py-3 shadow-md border border-white/50';
    const titleEl = document.createElement('div');
    titleEl.className = 'text-sm sm:text-base text-gray-900 mb-3 font-medium';
    titleEl.textContent = '¿Qué LED quieres controlar?';
    const grid = document.createElement('div');
    grid.className = 'grid grid-cols-3 gap-2';
    opts.forEach(o => {
      const btn = document.createElement('button');
      btn.className = 'px-3 py-2 text-xs sm:text-sm rounded-lg bg-gradient-to-r from-blue-500 to-cyan-500 text-white font-semibold shadow hover:brightness-110';
      btn.textContent = o.label;
      btn.addEventListener('click', () => {
        wrapper.remove();
        handleLedByNumber(o.meta.n, action);
      });
      grid.appendChild(btn);
    });
    content.appendChild(titleEl);
    content.appendChild(grid);
    wrapper.appendChild(avatar);
    wrapper.appendChild(content);
    messages.appendChild(wrapper);
    messages.scrollTop = messages.scrollHeight;
  }

  /** @param {string} text */
  async function sendMessage(text) {
    setError('');
    addMessage(text, 'user');

    // Interceptar comandos de luces si hay endpoints configurados
    const kind = isLedCommand(text);
    if (kind && (LED_ON || LED_OFF)) {
      await handleLedCommand(kind);
      return;
    }

    const loader = createLoaderBubble();
    let connectionError = false;

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
      
      // Construir la URL completa del endpoint
      const endpoint = `${API_URL}/api/chat`;
      
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ mensaje: text }),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Error del servidor: ${response.status}`);
      }

      const data = await response.json();
      loader.remove();
      
      // Manejar diferentes estructuras de respuesta del backend
      // Puede ser: { reply: "..." }, { mensaje: "..." }, o directamente un string
      const responseText = data.reply || data.mensaje || data.respuesta || 
                          (typeof data === 'string' ? data : JSON.stringify(data));
      
      // Mostrar respuesta en tiempo real con efecto de escritura
      const { wrapper, textDiv } = addMessage('', 'assistant', true);
      await streamText(responseText, textDiv);

    } catch (err) {
      connectionError = true;
      console.error('Error de conexión:', err);
      
      loader.remove();
      
      // Determinar tipo de error
      let errorMsg = '';
      if (err.name === 'AbortError') {
        errorMsg = '⚠️ Timeout: El servidor tardó demasiado en responder';
      } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
        errorMsg = '⚠️ Error de conexión: No se pudo conectar al servidor';
      } else {
        errorMsg = `⚠️ Error: ${err.message}`;
      }
      
      setError(errorMsg + ' - Usando modo offline');
      
      // Esperar un momento antes de mostrar respuesta simulada
      await new Promise(resolve => setTimeout(resolve, 800));
      const mockResponse = getMockResponse(text);
      
      // Mostrar respuesta simulada con streaming
      const { wrapper, textDiv } = addMessage('', 'assistant', true);
      await streamText(mockResponse, textDiv);
      
      // Mantener el mensaje de error visible por más tiempo
      setTimeout(() => {
        if (errorBox && errorBox.textContent.includes(errorMsg)) {
          setError('');
        }
      }, 5000);
    }
  }

  function showWelcomeMessage() {
    addMessage('¡Hola! Soy tu asistente domótico. Puedo ayudarte a controlar las luces, puertas y consultar la temperatura. ¿En qué puedo ayudarte?', 'assistant');
  }

  if (form && input) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const inputEl = /** @type {HTMLInputElement} */ (input);
      const text = String(inputEl.value || '').trim();
      if (!text) return;
      inputEl.value = '';
      sendMessage(text);
    });
  }

  showWelcomeMessage();
</script>



