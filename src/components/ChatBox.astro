---
const { placeholder = 'Escribe un mensajeâ€¦' } = Astro.props;
---

<div class="w-full h-full flex flex-col">
	<div id="messages" class="flex-1 overflow-y-auto p-4 sm:p-6 space-y-4 sm:space-y-6 min-h-0">
	
	</div>

	<div class="border-t border-white/30 p-4 sm:p-5 bg-gradient-to-r from-white/5 to-white/10">
		<form id="chat-form" class="flex gap-2 sm:gap-3" autocomplete="off">
			<input id="user-input" name="message" class="flex-1 backdrop-blur-sm bg-white/90 border border-white/50 rounded-xl px-3 sm:px-4 py-2.5 sm:py-3 text-sm sm:text-base focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent shadow-lg transition-all" placeholder={placeholder} />
			<button type="submit" class="px-4 sm:px-6 py-2.5 sm:py-3 bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white text-sm sm:text-base font-bold rounded-xl transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-xl whitespace-nowrap">
				<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
				</svg>
			</button>
		</form>
		<div id="error" class="mt-3 hidden text-xs sm:text-sm text-red-100 bg-red-500/20 backdrop-blur-sm px-3 py-2 rounded-lg border border-red-300/30"></div>
	</div>
</div>

<script>
  // @ts-nocheck
  const form = /** @type {HTMLFormElement | null} */ (document.getElementById('chat-form'));
  const input = /** @type {HTMLInputElement | null} */ (document.getElementById('user-input'));
  const messages = /** @type {HTMLDivElement | null} */ (document.getElementById('messages'));
  const errorBox = /** @type {HTMLDivElement | null} */ (document.getElementById('error'));

  /** Renders a message bubble 
   * @param {string} text
   * @param {'user' | 'assistant'} role
   * @param {boolean=} streaming - Si es true, retorna el elemento de texto para streaming
   */
  function addMessage(text, role, streaming = false) {
    const wrapper = document.createElement('div');
    const isUser = role === 'user';
    wrapper.className = `flex gap-2 sm:gap-3 ${isUser ? 'justify-end' : ''}`;
    
    let textDiv;
    
    if (isUser) {
      const content = document.createElement('div');
      content.className = 'max-w-[85%] sm:max-w-[80%] bg-gradient-to-br from-blue-500 to-cyan-500 rounded-2xl px-3 sm:px-4 py-2.5 sm:py-3 shadow-lg';
      textDiv = document.createElement('div');
      textDiv.className = 'text-sm sm:text-base text-white leading-relaxed break-words';
      textDiv.textContent = text;
      content.appendChild(textDiv);
      wrapper.appendChild(content);
    } else {
      const avatar = document.createElement('div');
      avatar.className = 'w-8 h-8 sm:w-10 sm:h-10 bg-gradient-to-br from-cyan-500 to-blue-600 rounded-full flex items-center justify-center flex-shrink-0 shadow-lg';
      avatar.innerHTML = 'ðŸ¤–';
      avatar.style.fontSize = '1.25rem';
      
      const content = document.createElement('div');
      content.className = 'flex-1 min-w-0 backdrop-blur-sm bg-white/80 rounded-2xl px-3 sm:px-4 py-2.5 sm:py-3 shadow-md border border-white/50';
      textDiv = document.createElement('div');
      textDiv.className = 'text-sm sm:text-base text-gray-900 leading-relaxed break-words';
      textDiv.textContent = text;
      content.appendChild(textDiv);
      
      wrapper.appendChild(avatar);
      wrapper.appendChild(content);
    }
    
    if (messages) {
      messages.appendChild(wrapper);
      messages.scrollTop = messages.scrollHeight;
    }
    
    return streaming ? { wrapper, textDiv } : wrapper;
  }

  /** @param {string=} msg */
  function setError(msg) {
    if (!errorBox) return;
    if (!msg) {
      errorBox.classList.add('hidden');
      errorBox.textContent = '';
      return;
    }
    errorBox.textContent = String(msg);
    errorBox.classList.remove('hidden');
  }

  function createLoaderBubble() {
    const wrapper = document.createElement('div');
    wrapper.className = 'flex gap-2 sm:gap-3';
    
    const avatar = document.createElement('div');
    avatar.className = 'w-8 h-8 sm:w-10 sm:h-10 bg-gradient-to-br from-cyan-500 to-blue-600 rounded-full flex items-center justify-center flex-shrink-0 shadow-lg';
    avatar.innerHTML = 'ðŸ¤–';
    avatar.style.fontSize = '1.25rem';
    
    const content = document.createElement('div');
    content.className = 'flex-1 flex items-center gap-2 backdrop-blur-sm bg-white/80 rounded-2xl px-3 sm:px-4 py-3 shadow-md border border-white/50';
    
    const dots = document.createElement('div');
    dots.className = 'flex items-center gap-1.5';
    for (let i = 0; i < 3; i++) {
      const d = document.createElement('span');
      d.className = 'inline-block h-2 w-2 sm:h-2.5 sm:w-2.5 bg-gradient-to-r from-cyan-500 to-blue-600 rounded-full animate-bounce';
      d.style.animationDelay = `${i * 0.15}s`;
      dots.appendChild(d);
    }
    
    content.appendChild(dots);
    wrapper.appendChild(avatar);
    wrapper.appendChild(content);
    if (messages) {
      messages.appendChild(wrapper);
      messages.scrollTop = messages.scrollHeight;
    }
    return wrapper;
  }

  const mockResponses = {
    'encender': 'He encendido las luces segÃºn tu solicitud.',
    'prender': 'He encendido las luces segÃºn tu solicitud.',
    'apagar': 'He apagado las luces segÃºn tu solicitud.',
    'temperatura': 'La temperatura actual en tu hogar es de 22Â°C.',
    'abrir': 'He abierto la puerta segÃºn tu solicitud.',
    'cerrar': 'He cerrado la puerta segÃºn tu solicitud.',
    'hola': 'Â¡Hola! Soy tu asistente domÃ³tico. Â¿En quÃ© puedo ayudarte hoy?',
    'ayuda': 'Puedo ayudarte con: encender/apagar luces, abrir/cerrar puertas y consultar la temperatura actual.'
  };

  /** @param {string} text */
  function getMockResponse(text) {
    const lowerText = text.toLowerCase();
    for (const [key, response] of Object.entries(mockResponses)) {
      if (lowerText.includes(key)) {
        return response;
      }
    }
    return 'No entiendo ese comando. Di "ayuda" para ver los comandos disponibles.';
  }

  /** Simula streaming de texto con efecto de escritura
   * @param {string} fullText
   * @param {HTMLElement} textElement
   */
  async function streamText(fullText, textElement) {
    let currentText = '';
    const words = fullText.split(' ');
    
    for (let i = 0; i < words.length; i++) {
      currentText += (i > 0 ? ' ' : '') + words[i];
      textElement.textContent = currentText;
      if (messages) {
        messages.scrollTop = messages.scrollHeight;
      }
      // Velocidad de escritura variable para efecto mÃ¡s natural
      await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
    }
  }

  /** @param {string} text */
  async function sendMessage(text) {
    setError('');
    addMessage(text, 'user');

    const loader = createLoaderBubble();
    let connectionError = false;

    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
      
      const response = await fetch('http://localhost:3000/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: text }),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`Error del servidor: ${response.status}`);
      }

      const data = await response.json();
      loader.remove();
      
      // Mostrar respuesta en tiempo real con efecto de escritura
      const { wrapper, textDiv } = addMessage('', 'assistant', true);
      await streamText(data.reply, textDiv);

    } catch (err) {
      connectionError = true;
      console.error('Error de conexiÃ³n:', err);
      
      loader.remove();
      
      // Determinar tipo de error
      let errorMsg = '';
      if (err.name === 'AbortError') {
        errorMsg = 'âš ï¸ Timeout: El servidor tardÃ³ demasiado en responder';
      } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
        errorMsg = 'âš ï¸ Error de conexiÃ³n: No se pudo conectar al servidor';
      } else {
        errorMsg = `âš ï¸ Error: ${err.message}`;
      }
      
      setError(errorMsg + ' - Usando modo offline');
      
      // Esperar un momento antes de mostrar respuesta simulada
      await new Promise(resolve => setTimeout(resolve, 800));
      const mockResponse = getMockResponse(text);
      
      // Mostrar respuesta simulada con streaming
      const { wrapper, textDiv } = addMessage('', 'assistant', true);
      await streamText(mockResponse, textDiv);
      
      // Mantener el mensaje de error visible por mÃ¡s tiempo
      setTimeout(() => {
        if (errorBox && errorBox.textContent.includes(errorMsg)) {
          setError('');
        }
      }, 5000);
    }
  }

  function showWelcomeMessage() {
    addMessage('Â¡Hola! Soy tu asistente domÃ³tico. Puedo ayudarte a controlar las luces, puertas y consultar la temperatura. Â¿En quÃ© puedo ayudarte?', 'assistant');
  }

  if (form && input) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const inputEl = /** @type {HTMLInputElement} */ (input);
      const text = String(inputEl.value || '').trim();
      if (!text) return;
      inputEl.value = '';
      sendMessage(text);
    });
  }

  showWelcomeMessage();
</script>



